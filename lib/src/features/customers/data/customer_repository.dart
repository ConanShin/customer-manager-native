import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../domain/customer.dart';
import '../domain/repair.dart';
part 'customer_repository.g.dart';

class CustomerRepository {
  final SupabaseClient _client;

  CustomerRepository(this._client);

  Future<List<Customer>> getCustomers() async {
    List<dynamic> allData = [];
    int from = 0;
    int to = 999;
    bool keepFetching = true;

    try {
      while (keepFetching) {
        final response = await _client
            .from('customers')
            .select('*, hearing_aids(*), repairs(*)')
            .order('registration_date', ascending: false)
            .range(from, to);

        final List<dynamic> data = response as List<dynamic>;

        if (data.isEmpty) {
          keepFetching = false;
        } else {
          allData.addAll(data);
          from += 1000;
          to += 1000;
          if (data.length < 1000) {
            keepFetching = false;
          }
        }
      }
      return allData.map((e) => Customer.fromJson(e)).toList();
    } catch (e, stack) {
      print('Error fetching customers: $e');
      print(stack);
      rethrow;
    }
  }

  Future<void> addCustomer(Customer customer) async {
    final customerJson = customer.toJson();
    // Remove nested lists from customer insert, handle separate
    final hearingAids = customerJson.remove('hearing_aids') as List?;
    final repairs = customerJson.remove('repairs') as List?;

    // Supabase auto-generates IDs if we don't provide it, OR we provide UUID.
    // Existing customer might have ID. If it's empty, remove it to let DB generate?
    // Customer.id is required string. If it's empty string, we should probably generate one or let DB generate.
    // If our schema has `id text primary key`, we must provide it if not default.
    // My schema provided: `id text primary key` (no default gen_random_uuid() explicitly in the SQL I wrote? Wait, I wrote `create table customers (id text primary key...)`.
    // So I MUST provide ID.
    // If I want to generate UUID, I should use `uuid` package.
    // Or if I want Supabase to generate, I should have defined `default gen_random_uuid()`.
    // In my plan, I said "Keeping text ID".
    // Let's assume `customer.id` is valid.

    await _client.from('customers').insert(customerJson);

    if (hearingAids != null && hearingAids.isNotEmpty) {
      for (var ha in hearingAids) {
        if (ha is Map<String, dynamic>) {
          ha['customer_id'] = customer.id;
          // Remove 'id' if it is empty/dummy to let DB generate serial ID?
          // Schema: `id bigint generated by default as identity`
          // So we should REMOVE 'id' from insert map.
          ha.remove('id');
          await _client.from('hearing_aids').insert(ha);
        }
      }
    }

    if (repairs != null && repairs.isNotEmpty) {
      for (var r in repairs) {
        if (r is Map<String, dynamic>) {
          r['customer_id'] = customer.id;
          r.remove('id'); // let DB generate
          await _client.from('repairs').insert(r);
        }
      }
    }
  }

  Future<void> updateCustomer(Customer customer) async {
    final customerJson = customer.toJson();
    final hearingAids = customerJson.remove('hearing_aids') as List?;
    final repairs = customerJson.remove('repairs') as List?;

    await _client.from('customers').update(customerJson).eq('id', customer.id);

    // Simplistic approach: delete all and re-create for nested for now
    // This is not efficient but safe for full sync
    // Delete existing
    await _client.from('hearing_aids').delete().eq('customer_id', customer.id);
    await _client.from('repairs').delete().eq('customer_id', customer.id);

    // Re-insert
    if (hearingAids != null && hearingAids.isNotEmpty) {
      final List<Map<String, dynamic>> toInsert = [];
      for (var ha in hearingAids) {
        if (ha is Map<String, dynamic>) {
          ha['customer_id'] = customer.id;
          ha.remove('id');
          toInsert.add(ha);
        }
      }
      if (toInsert.isNotEmpty) {
        await _client.from('hearing_aids').insert(toInsert);
      }
    }

    if (repairs != null && repairs.isNotEmpty) {
      final List<Map<String, dynamic>> toInsert = [];
      for (var r in repairs) {
        if (r is Map<String, dynamic>) {
          r['customer_id'] = customer.id;
          r.remove('id');
          toInsert.add(r);
        }
      }
      if (toInsert.isNotEmpty) {
        await _client.from('repairs').insert(toInsert);
      }
    }
  }

  Future<void> deleteCustomer(String customerId) async {
    await _client.from('customers').delete().eq('id', customerId);
  }

  // Sanitization legacy method - keep empty or remove?
  // User might still want to call it?
  Future<List<String>> sanitizeAndMigrateData() async {
    // Re-implement if needed, for now just dummy
    return ['Migration not implemented for Supabase yet'];
  }
}

@riverpod
CustomerRepository customerRepository(Ref ref) {
  return CustomerRepository(Supabase.instance.client);
}

@riverpod
Future<List<Customer>> customersList(Ref ref) async {
  final repository = ref.watch(customerRepositoryProvider);
  return repository.getCustomers();
}
